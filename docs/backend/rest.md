---
title: REST
sidebar_position: 2
---

## Зачем?

Как говорилось в предыдущем уроке, HTTP — это текстовый протокол, по которому можно передавать любые данные с клиента на сервер и обратно. Но такая свобода может быть пагубной — без правил взаимодействия бэкэнда и фронтенда начнётся бардак. Чтобы упорядочить свободу, были придуманы различные подходы и протоколы поверх HTTP. Один из них REST.

Архитектурный стиль, позволяющий сделать сетевое взаимодействие удобнее, прозрачнее и стандартизованнее. (Рой Филдинг)

**REST** (Representational State Transfer — «передача состояния представления») определяет такие понятия, как ресурсы, представление для ресурсов, идентификатор ресурсов, а также описывает требования к взаимодействию (кеширование, связанность).

**HTTP** идеально подходит для применения данной архитектуры.

***

## Термины

### Ресурсы

В архитектуре REST все действия, которые совершает фронтенд, направлены на работу с ресурсами или сущностями. В курсе будем использовать слово «ресурс». Ресурс — это любой объект бизнес-логики, с которым работает приложение. Пользователь, сообщение, аватарка, товар, категория товара, любой объект реального мира — это ресурсы в REST.

### Идентификаторы ресурсов

Ресурсы в REST существуют не просто сами по себе и без цели, нет. Они нужны, чтобы фронтенд что-то с ними делал. Для этого фронтенду нужно знать, как отличать одни ресурсы от других, и для этой цели служат идентификаторы — уникальные значения, которые есть у каждого ресурса, зачастую обозначающиеся полем id.
Идентификаторы также используются для построения адреса запроса, об этом через пару абзацев.

### Действия с ресурсами

Работа любого приложения так или иначе сводится к манипуляции данными, и REST эти манипуляции стандартизирует, определяя, что можно делать с ресурсами:

- создавать,
- получать,
- обновлять,
- удалять.

Набор действий маленький и работать с ним просто. Но также это приносит определённые сложности — вам придётся мыслить категориями «ресурс» и «действие». В эти категории плохо укладываются бизнес-действия, такие как, например, «выплатить сотрудникам зарплату» — придётся придумывать сущности для этого действия и создавать их. Иногда это бывает излишней сложностью, из-за которой от REST отказываются, если приложение богато сложной бизнес-логикой.

***

## Запросы

Действия с ресурсами перекладываются на HTTP с помощью методов запросов — каждому действию соответствует свой метод. О том, какой метод HTTP, что означает в REST, будет ниже, а сейчас поговорим о том, на какие адреса эти запросы должны делаться.

Адреса запросов в REST формируются по принципу ```/ресурс(/id(/ресурс...)?)?```. Такие адреса иногда называется эндпоинтами (endpoint).

Выглядит сложно, разберёмся на примерах. Ресурсы могут выстраиваться в иерархии, и эти иерархии вы отображаете в адресе запроса.

Нужен список чатов? Ресурс — чат. Принцип ```/ресурс```. Запрос на ```/chats```.

Нужна информация о конкретном чате? Ресурс — чат. Конкретный чат — идентификатор. Принцип ```/ресурс/идентификатор```. Запрос ```/chats/123```.

Нужен список всех сообщений в чате? Ресурс — сообщение. Где находится этот ресурс? В другом ресурсе — в чате. В конкретном чате — за это отвечает идентификатор. Принцип ```/ресурс/идентификатор/ресурс```. Запрос ```/chats/123/messages```.

Нужно получить информацию о том, что можно сделать с конкретным сообщением в конкретном чате? Ресурс — действия. Где находится этот ресурс? В другом ресурсе — в сообщении. В каком сообщении — идентификатор сообщения. Где находится ресурс сообщения? В другом ресурсе — в чате. В каком чате — идентификатор чата. Принцип ```/ресурс/идентификатор/ресурс/идентификатор/ресурс```. Запрос ```/chats/123/messages/456/actions```.

И так далее.

Но в таких длинных цепочках есть своя опасность для бэкэнда, и, возможно, иногда не стоит держать ресурс «сообщения» в ресурсе «чат» для работы с сообщениями. Для этого может быть достаточно отдельного эндпоинта ```/messages```, чтобы строить запросы от него ```/messages/456/actions```.

### Идемпотентность

Так называется свойство, при котором повторный запрос даёт тот же результат, что и первый. Оно не является свойством по умолчанию и не гарантируется сервером, то есть появляется как результат реализации запроса. 

[Идемпотентные методы](https://developer.mozilla.org/ru/docs/Glossary/Idempotent):

- GET,
- OPTIONS,
- HEAD,
- PUT,
- DELETE.

Методы POST и PATCH — не идемпотентны.

Может показаться «Как же так?! А если между двумя GET-запросами будет PATCH — результаты GET будут разные». Идемпотентность не про это. Она про то, что идемпотентные запросы не должны менять состояние ресурсов на сервере. Бэкэнд-разработчики должны быть осведомлены об этом и не нарушать это свойство.

***

### Семантика

#### GET

Получает состояние ресурса в одном из представлений (JSON, XML, HTML), не содержит тела:

```bash
GET /chats  // получить все чаты
GET /chats/123  // получить информацию о чате с идентификатором 123
GET /chats/123/messages  // получить все сообщения из чата с идентифиакатором 123
GET /chats?limit=10  // получить 10 чатов

200 Ok // Получили успешно

404 Not found // Ресурс не найден
400 Bad request /chats?limit=muahahaha // Запрос составлен клиентом некорректно
```

***

#### POST

Создаёт новый ресурс с начальным состоянием, когда сервис не знает его ID, содержит тело:

```bash
POST /chats  // создать новый чат
{
  "data": {...}
}

201 Created // Успешно создано

409 Conflict // Такой документ уже есть (например, пользователь с таким email уже зарегистрирован)
```

***

#### PUT

Создаёт новый ресурс с начальным состоянием, когда сервис знает его ID. Целиком обновляет состояние текущего ресурса, содержит тело:

```bash
PUT /chats/123  // создать новый чат с идентификатором 123
{
  "data": {...}
}

200 Ok // Выполнено успешно
204 No content

404 Not found // Ресурс не найден
```

***

#### DELETE

Удаляет существующий ресурс, не содержит тела:

```bash
DELETE /chats/123  // удалить чат с идентификатором 123
DELETE /chats/123/messages  // удалить все сообщения из чата с идентификатором 123

200 Ok
204 No content

404 Not found
```

***

#### PATCH

Частично обновляет состояние существующего ресурса, содержит тело:

```bash
PATCH /chats/123
{
  "data": {...}
}

200 Ok
204 No content

404 Not found
```

Про отличия PATCH и PUT можно [почитать в стандарте](https://www.rfc-editor.org/rfc/rfc5789).

***

#### HEAD

Запрашивает заголовки, чтобы проверить существование ресурса, не содержит тела:

```bash
HEAD /chats/123

200 Ok

404 Not found 
```

***

#### OPTIONS

Запрашивает правила взаимодействия, например, доступные методы, не содержит тела:

```bash
OPTIONS /search

204 No content
Allow: OPTIONS, GET, HEAD

POST /search

405 Method not allowed 
```

***

## Лучшие практики в REST

Как можно делать правильно, но не описано в REST:

1. Используйте path, а не query:

```bash
// Неправильно:
/api?type=chats&id=123

// Правильно:
/api/chats/123 
```

***

2. Используйте в названиях множественное число:

```bash
// Неправильно:
/api/chat/123

// Правильно:
/api/chats/123 
```

***

3. Используйте только существительные.

В HTTP методы отвечают за действия: 

- **POST** — создать,
- **GET** — получить.

Глагол здесь — избыточная информация.

```bash
// Неправильно:
POST /api/chats/add

// Правильно:
POST /api/chats 
```

***

4. Используйте короткие имена:

```bash
// Неправильно:
/api/chat_list

// Правильно:
/api/chats  
```

***

5. Используйте строчные буквы. Это общепринятая форма отображения URL в браузере, даже если в проекте на JavaScript принят camelCase:

```bash
// Неправильно:
/api/pullRequest

// Правильно:
/api/pull-request   
```

***

6. Вложенность лучше параметров:

```bash
// Неправильно:
/api/messages?chat_id=213

// Правильно:
/api/chats/123/messages   
```
